<#@ template hostSpecific="true" debug="false" #>
<#@ output extension="generated.cs" #>
<#@ assembly name="EnvDTE" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Data.Linq" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ import namespace="EnvDTE" #>
<#@ import namespace="System" #>
<#@ import namespace="System.CodeDom" #>
<#@ import namespace="System.CodeDom.Compiler" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.ComponentModel" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Xml.Schema" #>
<#@ import namespace="System.Xml.Serialization" #>
<#@ import namespace="Microsoft.CSharp" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<# var manager = Manager.Create(Host, GenerationEnvironment); #>
//-----------------------------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version: <#= Environment.Version.ToString() #>
//
//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>
//-----------------------------------------------------------------------------------------------------

// If you use this template inside a _portable_ class library,
// then you should define the PORTABLE conditional compilation symbol
// in order to enable the creation of some necessary stub classes.
#if PORTABLE

namespace System
{
    /// <summary>
    ///   Fake, this is used only to allow serialization on portable platforms.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Enum, AllowMultiple = true, Inherited = false)]
    internal sealed class SerializableAttribute : Attribute
    {
        // This does nothing and should do nothing.
    }
}

#endif

<#
    var xsdClassGen = new XsdClassGen(manager.GetItemNamespace(Host.TemplateFile));
    var hostServiceProvider = (IServiceProvider) Host;
    var dte = (DTE) hostServiceProvider.GetService(typeof(DTE));
    var templateProjectItem = dte.Solution.FindProjectItem(Host.TemplateFile);
    var project = templateProjectItem.ContainingProject;
    var paths = GetAllItems(project.ProjectItems.Cast<ProjectItem>()).Select(projectItem => projectItem.FileNames[0]).ToList();
    foreach (var path in paths.Where(path => path.EndsWith(".xsd"))) {
        xsdClassGen.AddSchema(path);
    }
    foreach (var path in paths.Where(path => path.EndsWith("XsdClassGen.mapping"))) {
        xsdClassGen.LoadMappings(path);
    }
    IDictionary<string, List<string>> typeNameMappings;
    using (var writer = new StringWriter(GenerationEnvironment)) {
        typeNameMappings = xsdClassGen.Generate(writer);
    }
    foreach (var codeNamespace in typeNameMappings.Keys) {
        foreach (var typeName in typeNameMappings[codeNamespace]) {
            manager.StartNewFile(codeNamespace + "." + typeName + ".Serialization.generated.cs");
#>
//-----------------------------------------------------------------------------------------------------
// <auto-generated>
//     This source code was auto-generated by XsdClassGen.tt.
//     Runtime Version: <#= Environment.Version.ToString() #>
//
//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>
//-----------------------------------------------------------------------------------------------------

using System;
using System.IO;
using System.Xml;
using System.Xml.Serialization;

namespace <#= codeNamespace #>
{
    /// <summary>
    ///   Automatically generated mapping for the <#= typeName #> XML element
    ///   declared in the <#= codeNamespace #> namespace.
    /// </summary>
	public partial class <#= typeName #>
	{
        /// <summary>
        ///   Deserializes given string into an instance of <see cref="<#= typeName #>" />.
        /// </summary>
        /// <param name="str">The string from which an instance of <see cref="<#= typeName #>" /> should be deserialized.</param>
        /// <returns>An instance of <see cref="<#= typeName #>" /> deserialized from given string.</returns>
        /// <exception cref="ArgumentException">Given string is null or empty.</exception>
		public static <#= typeName #> DeserializeFrom(string str)
		{
            if (String.IsNullOrEmpty(str)) {
                throw new ArgumentException("Cannot deserialize from a null or empty string.", "str");
            }
			var serializer = new XmlSerializer(typeof(<#= typeName #>));
		    using (var stream = new StringReader(str)) {
			    return serializer.Deserialize(stream) as <#= typeName #>;
		    }
		}        
        
        /// <summary>
        ///   Deserializes given stream into an instance of <see cref="<#= typeName #>" />.
        /// </summary>
        /// <param name="stream">The stream from which an instance of <see cref="<#= typeName #>" /> should be deserialized.</param>
        /// <returns>An instance of <see cref="<#= typeName #>" /> deserialized from given stream.</returns>
        /// <exception cref="ArgumentNullException">Given stream is null.</exception>
		public static <#= typeName #> DeserializeFrom(Stream stream)
		{
            if (stream == null) {
                throw new ArgumentNullException("stream");
            }
			var serializer = new XmlSerializer(typeof(<#= typeName #>));
			return serializer.Deserialize(stream) as <#= typeName #>;
		}

        /// <summary>
        ///   Deserializes given reader into an instance of <see cref="<#= typeName #>" />.
        /// </summary>
        /// <param name="reader">The reader from which an instance of <see cref="<#= typeName #>" /> should be deserialized.</param>
        /// <returns>An instance of <see cref="<#= typeName #>" /> deserialized from given reader.</returns>
        /// <exception cref="ArgumentNullException">Given reader is null.</exception>
		public static <#= typeName #> DeserializeFrom(TextReader reader)
		{            
            if (reader == null) {
                throw new ArgumentNullException("reader");
            }
			var serializer = new XmlSerializer(typeof(<#= typeName #>));
			return serializer.Deserialize(reader) as <#= typeName #>;
		}
        
        /// <summary>
        ///   Deserializes given reader into an instance of <see cref="<#= typeName #>" />.
        /// </summary>
        /// <param name="reader">The reader from which an instance of <see cref="<#= typeName #>" /> should be deserialized.</param>
        /// <returns>An instance of <see cref="<#= typeName #>" /> deserialized from given reader.</returns>
        /// <exception cref="ArgumentNullException">Given reader is null.</exception>
		public static <#= typeName #> DeserializeFrom(XmlReader reader)
		{            
            if (reader == null) {
                throw new ArgumentNullException("reader");
            }
			var serializer = new XmlSerializer(typeof(<#= typeName #>));
			return serializer.Deserialize(reader) as <#= typeName #>;
		}
        
        /// <summary>
        ///   Serializes this instance of <see cref="<#= typeName #>" /> into given string.
        /// </summary>
        /// <param name="str">The string into which the instance of <see cref="<#= typeName #>" /> should be serialized.</param>
		public void SerializeTo(ref string str)
		{
			var serializer = new XmlSerializer(typeof(<#= typeName #>));
            using (var stream = new StringWriter()) {
			    serializer.Serialize(stream, this);
                str = stream.ToString();
            }
		}
        
        /// <summary>
        ///   Serializes this instance of <see cref="<#= typeName #>" /> into given stream.
        /// </summary>
        /// <param name="stream">The stream into which the instance of <see cref="<#= typeName #>" /> should be serialized.</param>
        /// <exception cref="ArgumentNullException">Given stream is null.</exception>
		public void SerializeTo(Stream stream)
		{            
            if (stream == null) {
                throw new ArgumentNullException("stream");
            }
			var serializer = new XmlSerializer(typeof(<#= typeName #>));
			serializer.Serialize(stream, this);
		}
        
        /// <summary>
        ///   Serializes this instance of <see cref="<#= typeName #>" /> into given writer.
        /// </summary>
        /// <param name="writer">The writer into which the instance of <see cref="<#= typeName #>" /> should be serialized.</param>
        /// <exception cref="ArgumentNullException">Given writer is null.</exception>
		public void SerializeTo(TextWriter writer)
		{            
            if (writer == null) {
                throw new ArgumentNullException("writer");
            }
			var serializer = new XmlSerializer(typeof(<#= typeName #>));
			serializer.Serialize(writer, this);
		}
        
        /// <summary>
        ///   Serializes this instance of <see cref="<#= typeName #>" /> into given writer.
        /// </summary>
        /// <param name="writer">The writer into which the instance of <see cref="<#= typeName #>" /> should be serialized.</param>
        /// <exception cref="ArgumentNullException">Given writer is null.</exception>
		public void SerializeTo(XmlWriter writer)
		{            
            if (writer == null) {
                throw new ArgumentNullException("writer");
            }
			var serializer = new XmlSerializer(typeof(<#= typeName #>));
			serializer.Serialize(writer, this);
		}
	}
}
<#
            manager.EndBlock();
        }
    }
    manager.Process(true);
#>
<#+

    private static IEnumerable<ProjectItem> GetAllItems(IEnumerable<ProjectItem> projectItems)
    {
        return projectItems.Concat(projectItems.SelectMany(i => GetAllItems(i.ProjectItems.Cast<ProjectItem>())));
    }

    public class XsdClassGen
    {
        private readonly CodeDomProvider _codeProvider;
        private readonly string _defaultCodeNamespace;
        private readonly Dictionary<string, SchemaMapping> _schemaMappings = new Dictionary<string, SchemaMapping>();
        private readonly XmlSchemas _schemas = new XmlSchemas();

        public XsdClassGen()
            : this(new CSharpCodeProvider(), "") {}

        public XsdClassGen(string defaultCodeNamespace)
            : this(new CSharpCodeProvider(), defaultCodeNamespace) {}

        public XsdClassGen(CodeDomProvider codeProvider, string defaultCodeNamespace)
        {
            _codeProvider = codeProvider;
            _defaultCodeNamespace = defaultCodeNamespace;
        }

        public void AddSchema(string path)
        {
            using (var stream = File.OpenRead(path)) {
                var schema = XmlSchema.Read(stream, null);
                _schemas.Add(schema);
                if (schema.TargetNamespace == null) {
                    var fileName = Path.GetFileName(path);
                    throw new XmlSchemaException("XML Schema " + fileName + " does not specify a namespace, please set a 'targetNamespace' and an 'xmlns' attribute in the root element.");
                }
                ApplySchemaNamespaceMapping(schema.TargetNamespace, _defaultCodeNamespace);
            }
        }

        public void LoadMappings(string path)
        {
            using (var reader = File.OpenText(path)) {
                string line;
                while ((line = reader.ReadLine()) != null) {
                    line = line.Trim();
                    if ((line.Length == 0) || (line.StartsWith("#"))) {
                        continue;
                    }
                    var mapping = line.Split(',');
                    if (mapping.Length == 2) {
                        ApplySchemaNamespaceMapping(mapping[0], mapping[1]);
                    }
                    if (mapping.Length == 3) {
                        ApplyTypeNameMapping(mapping[0], mapping[1], mapping[2]);
                    }
                }
            }
        }

        public void ApplySchemaNamespaceMapping(string schemaNamespace, string codeNamespace)
        {
            if (_schemaMappings.Keys.Contains(schemaNamespace)) {
                _schemaMappings[schemaNamespace].CodeNamespace = codeNamespace;
            } else {
                _schemaMappings.Add(schemaNamespace,
                    new SchemaMapping {SchemaNamespace = schemaNamespace, CodeNamespace = codeNamespace});
            }
        }

        public void ApplyTypeNameMapping(string schemaNamespace, string elementName, string typeName)
        {
            SchemaMapping mapping;
            if (_schemaMappings.Keys.Contains(schemaNamespace)) {
                mapping = _schemaMappings[schemaNamespace];
            } else {
                ApplySchemaNamespaceMapping(schemaNamespace, _defaultCodeNamespace);
                mapping = _schemaMappings[schemaNamespace];
            }
            if (mapping.TypeMappings.Keys.Contains(elementName)) {
                mapping.TypeMappings[elementName] = typeName;
            } else {
                mapping.TypeMappings.Add(elementName, typeName);
            }
        }

        public IDictionary<string, List<string>> Generate(TextWriter writer)
        {
            var rootElementTypes = new Dictionary<string, List<string>>();
            var codeGeneratorOptions = new CodeGeneratorOptions();
            var schemaImporter = new XmlSchemaImporter(_schemas);
            _schemas.Compile(null, true);
            foreach (var mapping in _schemaMappings.Values) {
                var codeNamespace = GenerateCodeForMapping(mapping, schemaImporter);
                AddCommentsToCode(codeNamespace);
                MakeCodePortable(codeNamespace);
                _codeProvider.GenerateCodeFromNamespace(codeNamespace, writer, codeGeneratorOptions);
                var rootTypes = GetSchemaRootElementTypeNames(codeNamespace).ToList();
                if (rootElementTypes.ContainsKey(mapping.CodeNamespace)) {
                    var types = rootElementTypes[mapping.CodeNamespace];
                    types.AddRange(rootTypes);
                } else {
                    rootElementTypes.Add(mapping.CodeNamespace, rootTypes);
                }
            }
            return rootElementTypes;
        }

        private System.CodeDom.CodeNamespace GenerateCodeForMapping(SchemaMapping mapping, XmlSchemaImporter schemaImporter)
        {
            var codeNamespace = new System.CodeDom.CodeNamespace(mapping.CodeNamespace);
            var codeExporter = new XmlCodeExporter(codeNamespace);
            var maps = new List<XmlTypeMapping>();
            maps.AddRange(_schemas
                .Where(schema => schema.TargetNamespace == mapping.SchemaNamespace)
                .SelectMany(schema => schema.SchemaTypes.Values.Cast<XmlSchemaType>()
                    .Select(schemaType => schemaImporter.ImportSchemaType(schemaType.QualifiedName))));
            maps.AddRange(_schemas
                .Where(schema => schema.TargetNamespace == mapping.SchemaNamespace)
                .SelectMany(schema => schema.Elements.Values.Cast<XmlSchemaElement>()
                    .Select(schemaElement => schemaImporter.ImportTypeMapping(schemaElement.QualifiedName))));
            foreach (var map in maps) {
                codeExporter.ExportTypeMapping(map);
            }
            CodeGenerator.ValidateIdentifiers(codeNamespace);
            ApplyTypeMappings(codeNamespace, mapping);
            return codeNamespace;
        }

        private static void AddCommentsToCode(System.CodeDom.CodeNamespace codeNamespace)
        {
            const string typeDocFmt = @"
<summary>
   Automatically generated XML type mapping for {0}.
 </summary>
 <remarks>
   This is an automaticaly generated type, please do not edit it.
 </remarks>";

            const string propDocFmt = @"
<summary>
   Gets or sets {0}.
 </summary>";

            const string ctorDocFmt = @"
<summary>
   Initializes a new {0}.
 </summary>";

            const string enumDocFmt = @"
<summary>
   Value '{0}' for enumeration {1}.
 </summary>";

            /*** Types ***/
            foreach (CodeTypeDeclaration t in codeNamespace.Types)
            {
                var typeDoc = String.Format(typeDocFmt, t.Name);
                t.Comments.Clear();
                t.Comments.Add(new CodeCommentStatement(typeDoc.Trim(), true));

                /*** Properties ***/
                foreach (CodeTypeMember m in t.Members)
                {
                    if (!(m is CodeMemberProperty))
                    {
                        continue;
                    }
                    var propDoc = String.Format(propDocFmt, m.Name);
                    m.Comments.Clear();
                    m.Comments.Add(new CodeCommentStatement(propDoc.Trim(), true));
                }

                /*** Constructors ***/
                foreach (CodeTypeMember m in t.Members)
                {
                    if (!(m is CodeMemberMethod))
                    {
                        continue;
                    }
                    var ctorDoc = String.Format(ctorDocFmt, t.Name);
                    m.Comments.Clear();
                    m.Comments.Add(new CodeCommentStatement(ctorDoc.Trim(), true));
                }

                /*** Enum ***/
                if (t.IsEnum)
                {
                    /*** Enum values ***/
                    foreach (CodeTypeMember m in t.Members)
                    {
                        var enumDoc = String.Format(enumDocFmt, m.Name, t.Name);
                        m.Comments.Clear();
                        m.Comments.Add(new CodeCommentStatement(enumDoc.Trim(), true));
                    }
                }
            }
        }

        private static void MakeCodePortable(System.CodeDom.CodeNamespace codeNamespace)
        {
            /*** Types ***/
            foreach (CodeTypeDeclaration t in codeNamespace.Types)
            {
                // To allow portability
                for (var i = 0; i < t.CustomAttributes.Count; ++i)
                {
                    if (t.CustomAttributes[i].Name.Contains("DesignerCategoryAttribute"))
                    {
                        t.CustomAttributes.RemoveAt(i);
                        break;
                    }
                }
            }
        }

        private static void ApplyTypeMappings(System.CodeDom.CodeNamespace codeNamespace, SchemaMapping mapping)
        {
            foreach (var elementName in mapping.TypeMappings.Keys) {
                var typeName = mapping.TypeMappings[elementName];
                var codeType = FindTypeForSchemaRoot(codeNamespace, mapping.SchemaNamespace, elementName);
                var oldName = codeType.Name;
                codeType.Name = typeName;
                UpdateAttributeArguments<XmlRootAttribute>(codeType, "", oldName);
                UpdateAttributeArguments<XmlTypeAttribute>(codeType, "TypeName", oldName);
            }
        }

        private IEnumerable<string> GetSchemaRootElementTypeNames(System.CodeDom.CodeNamespace codeNamespace)
        {
            return _schemas
                .SelectMany(xsd => xsd.Elements.Values.Cast<XmlSchemaElement>())
                .Where(e => e.ElementSchemaType is XmlSchemaComplexType)
                .Select(e => FindTypeForSchemaRoot(codeNamespace, e.QualifiedName.Namespace, e.QualifiedName.Name))
                .Where(t => t != null)
                .Select(t => t.Name);
        }

        private static CodeTypeDeclaration FindTypeForSchemaRoot(System.CodeDom.CodeNamespace codeNamespace, string schemaNs, string elementName)
        {
            return codeNamespace.Types.Cast<CodeTypeDeclaration>().FirstOrDefault(t => HasXmlRootAttribute(t, schemaNs, elementName));
        }

        private static bool HasXmlRootAttribute(CodeTypeMember codeType, string schemaNs, string elementName)
        {
            var rootAttrib = GetCodeAttributeDeclaration<XmlRootAttribute>(codeType);
            if (rootAttrib == null) {
                return false;
            }
            var nsArg = GetAttributeArgument(rootAttrib, "Namespace");
            if (nsArg == null) {
                return false;
            }
            if ((string) GetAttributeArgumentValue(nsArg) != schemaNs) {
                return false;
            }
            var nameArg = GetAttributeArgument(rootAttrib, "");
            var name = codeType.Name;
            if (nameArg != null) {
                name = (string) GetAttributeArgumentValue(nameArg);
            }
            return name == elementName;
        }

        private static void UpdateAttributeArguments<T>(CodeTypeMember codeType, string findArg, string oldValue) where T : Attribute
        {
            var attrib = GetCodeAttributeDeclaration<T>(codeType);
            var arg = GetAttributeArgument(attrib, findArg);
            if (arg != null) {
                return;
            }
            arg = new CodeAttributeArgument(findArg, new CodePrimitiveExpression(oldValue));
            attrib.Arguments.Insert(0, arg);
        }

        private static CodeAttributeDeclaration GetCodeAttributeDeclaration<T>(CodeTypeMember type)
        {
            return type.CustomAttributes.Cast<CodeAttributeDeclaration>().FirstOrDefault(a => a.Name == typeof(T).FullName);
        }

        private static CodeAttributeArgument GetAttributeArgument(CodeAttributeDeclaration attribute, string argument)
        {
            return attribute.Arguments.Cast<CodeAttributeArgument>().FirstOrDefault(a => a.Name == argument);
        }

        private static object GetAttributeArgumentValue(CodeAttributeArgument arg)
        {
            return arg == null ? null : ((CodePrimitiveExpression) arg.Value).Value;
        }

        #region Nested type: SchemaMapping

        private class SchemaMapping
        {
            public SchemaMapping()
            {
                TypeMappings = new Dictionary<string, string>();
            }

            public string SchemaNamespace { get; set; }
            public string CodeNamespace { get; set; }
            public IDictionary<string, string> TypeMappings { get; private set; }
        }

        #endregion
    }

    // Manager class records the various blocks so it can split them up
    // From http://damieng.com/blog/2009/11/06/multiple-outputs-from-t4-made-easy-revisited
    private class Manager
    {
        private readonly List<Block> _files = new List<Block>();
        private readonly Block _footer = new Block();
        private readonly List<String> _generatedFileNames = new List<String>();
        private readonly Block _header = new Block();
        private readonly ITextTemplatingEngineHost _host;
        private readonly StringBuilder _template;
        private Block _currentBlock;

        private Manager(ITextTemplatingEngineHost host, StringBuilder template)
        {
            _host = host;
            _template = template;
        }

        public virtual String DefaultProjectNamespace
        {
            get { return null; }
        }

        private Block CurrentBlock
        {
            get { return _currentBlock; }
            set
            {
                if (CurrentBlock != null) {
                    EndBlock();
                }
                if (value != null) {
                    value.Start = _template.Length;
                }
                _currentBlock = value;
            }
        }

        public static Manager Create(ITextTemplatingEngineHost host, StringBuilder template)
        {
            return (host is IServiceProvider) ? new VSManager(host, template) : new Manager(host, template);
        }

        public void StartNewFile(String name)
        {
            if (name == null) {
                throw new ArgumentNullException("name");
            }
            CurrentBlock = new Block {Name = name};
        }

        public void StartFooter()
        {
            CurrentBlock = _footer;
        }

        public void StartHeader()
        {
            CurrentBlock = _header;
        }

        public void EndBlock()
        {
            if (CurrentBlock == null) {
                return;
            }
            CurrentBlock.Length = _template.Length - CurrentBlock.Start;
            if (CurrentBlock != _header && CurrentBlock != _footer) {
                _files.Add(CurrentBlock);
            }
            _currentBlock = null;
        }

        public virtual void Process(bool split)
        {
            if (split) {
                EndBlock();
                var headerText = _template.ToString(_header.Start, _header.Length);
                var footerText = _template.ToString(_footer.Start, _footer.Length);
                var outputPath = Path.GetDirectoryName(_host.TemplateFile);
                _files.Reverse();
                foreach (var block in _files) {
                    var fileName = Path.Combine(outputPath, block.Name);
                    var content = headerText + _template.ToString(block.Start, block.Length) + footerText;
                    _generatedFileNames.Add(fileName);
                    CreateFile(fileName, content);
                    _template.Remove(block.Start, block.Length);
                }
            }
        }

        protected virtual void CreateFile(String fileName, String content)
        {
            if (IsFileContentDifferent(fileName, content)) {
                File.WriteAllText(fileName, content);
            }
        }

        public virtual String GetCustomToolNamespace(String fileName)
        {
            return null;
        }

        public virtual String GetItemNamespace(String filename)
        {
            var customNamespace = GetCustomToolNamespace(filename);
            return String.IsNullOrEmpty(customNamespace) ? DefaultProjectNamespace : customNamespace;
        }

        protected static bool IsFileContentDifferent(String fileName, String newContent)
        {
            return !(File.Exists(fileName) && File.ReadAllText(fileName) == newContent);
        }

        #region Nested type: Block

        private class Block
        {
            public int Length;
            public String Name;
            public int Start;
        }

        #endregion

        #region Nested type: VSManager

        private class VSManager : Manager
        {
            private readonly Action<String> _checkOutAction;
            private readonly DTE _dte;
            private readonly Action<IEnumerable<String>> _projectSyncAction;
            private readonly ProjectItem _templateProjectItem;

            internal VSManager(ITextTemplatingEngineHost host, StringBuilder template)
                : base(host, template)
            {
                var hostServiceProvider = (IServiceProvider) host;
                if (hostServiceProvider == null) {
                    throw new ArgumentNullException("host", "Could not obtain IServiceProvider");
                }
                _dte = (DTE) hostServiceProvider.GetService(typeof(DTE));
                if (_dte == null) {
                    throw new ArgumentNullException("host", "Could not obtain DTE from host");
                }
                _templateProjectItem = _dte.Solution.FindProjectItem(host.TemplateFile);
                _checkOutAction = fileName => _dte.SourceControl.CheckOutItem(fileName);
                _projectSyncAction = keepFileNames => ProjectSync(_templateProjectItem, keepFileNames);
            }

            public override String DefaultProjectNamespace
            {
                get { return _templateProjectItem.ContainingProject.Properties.Item("RootNamespace").Value.ToString(); }
            }

            public override String GetItemNamespace(String filename)
            {
                var customNamespace = GetCustomToolNamespace(filename);
                if (!String.IsNullOrEmpty(customNamespace)) {
                    return customNamespace;
                }

                var namespaces = new List<string>();
                var parent = _templateProjectItem.Collection.Parent as ProjectItem;
                while (parent != null) {
                    if (parent.Kind != Constants.vsProjectItemKindPhysicalFile) {
                        namespaces.Insert(0, parent.Name.Replace(" ", string.Empty));
                    }

                    parent = parent.Collection.Parent as ProjectItem;
                }

                namespaces.Insert(0, DefaultProjectNamespace);
                return string.Join(".", namespaces.ToArray());
            }

            public override String GetCustomToolNamespace(string fileName)
            {
                return _dte.Solution.FindProjectItem(fileName).Properties.Item("CustomToolNamespace").Value.ToString();
            }

            public override void Process(bool split)
            {
                if (_templateProjectItem.ProjectItems == null) {
                    return;
                }
                base.Process(split);
                _projectSyncAction.EndInvoke(_projectSyncAction.BeginInvoke(_generatedFileNames, null, null));
            }

            protected override void CreateFile(String fileName, String content)
            {
                if (IsFileContentDifferent(fileName, content)) {
                    CheckoutFileIfRequired(fileName);
                    File.WriteAllText(fileName, content);
                }
            }

            private static void ProjectSync(ProjectItem templateProjectItem, IEnumerable<String> keepFileNames)
            {
                var keepFileNameSet = new HashSet<String>(keepFileNames);
                var originalFilePrefix = Path.GetFileNameWithoutExtension(templateProjectItem.FileNames[0]) + ".";
                var projectFiles = templateProjectItem.ProjectItems.Cast<ProjectItem>().ToDictionary(projectItem => projectItem.FileNames[0]);

                // Remove unused items from the project
                foreach (var pair in projectFiles) {
                    if (!keepFileNames.Contains(pair.Key) && !(Path.GetFileNameWithoutExtension(pair.Key) + ".").StartsWith(originalFilePrefix)) {
                        pair.Value.Delete();
                    }
                }

                // Add missing files to the project
                foreach (var fileName in keepFileNameSet.Where(fileName => !projectFiles.ContainsKey(fileName))) {
                    templateProjectItem.ProjectItems.AddFromFile(fileName);
                }
            }

            private void CheckoutFileIfRequired(String fileName)
            {
                var sc = _dte.SourceControl;
                if (sc != null && sc.IsItemUnderSCC(fileName) && !sc.IsItemCheckedOut(fileName)) {
                    _checkOutAction.EndInvoke(_checkOutAction.BeginInvoke(fileName, null, null));
                }
            }
        }

        #endregion
    }

#>